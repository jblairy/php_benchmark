# P2.2 & P2.3: Before/After Code Examples

## P2.2: Boolean Flags → Strategy Pattern

### Example 1: EnhancedStatisticsCalculator

#### BEFORE (Boolean Flag Anti-Pattern)
```php
final readonly class EnhancedStatisticsCalculator
{
    public function __construct(
        private OutlierDetector $outlierDetector,
        private bool $removeOutliers = true,  // ❌ Boolean flag changes behavior
    ) {}

    private function selectDataForAnalysis(
        OutlierDetectionResult $outlierResult,
        BenchmarkMetrics $benchmarkMetrics,
    ): array {
        // ❌ Conditional logic based on boolean flag
        return $this->removeOutliers
            ? $outlierResult->cleanedData
            : $benchmarkMetrics->executionTimes;
    }
}

// Usage:
$calculator = new EnhancedStatisticsCalculator($detector, removeOutliers: true);
```

**Problems:**
- ❌ Boolean flag changes class behavior (SRP violation)
- ❌ Hard to extend with new strategies
- ❌ Conditional logic scattered throughout class
- ❌ Not following Open/Closed Principle

#### AFTER (Strategy Pattern)
```php
// Strategy Interface
interface OutlierHandlingStrategy
{
    public function selectDataForAnalysis(array $cleanedData, array $originalData): array;
    public function getAnalysisCount(OutlierDetectionResult $outlierResult, int $originalCount): int;
}

// Concrete Strategies
final readonly class RemoveOutliersStrategy implements OutlierHandlingStrategy
{
    public function selectDataForAnalysis(array $cleanedData, array $originalData): array
    {
        return $cleanedData;
    }
}

final readonly class KeepOutliersStrategy implements OutlierHandlingStrategy
{
    public function selectDataForAnalysis(array $cleanedData, array $originalData): array
    {
        return $originalData;
    }
}

// Refactored Calculator
final readonly class EnhancedStatisticsCalculator
{
    public function __construct(
        private OutlierDetector $outlierDetector,
        private OutlierHandlingStrategy $outlierHandlingStrategy,  // ✅ Strategy injection
    ) {}

    private function selectDataForAnalysis(
        OutlierDetectionResult $outlierResult,
        BenchmarkMetrics $benchmarkMetrics,
    ): array {
        // ✅ Delegate to strategy
        return $this->outlierHandlingStrategy->selectDataForAnalysis(
            $outlierResult->cleanedData,
            $benchmarkMetrics->executionTimes,
        );
    }
}

// Usage:
$calculator = new EnhancedStatisticsCalculator($detector, new RemoveOutliersStrategy());
```

**Benefits:**
- ✅ Single Responsibility - Calculator focuses on calculation, strategy handles outlier logic
- ✅ Open/Closed - Easy to add new strategies without modifying calculator
- ✅ Testable - Each strategy can be tested independently
- ✅ Flexible - Can inject different strategies at runtime

---

### Example 2: CalibrationService

#### BEFORE (Boolean Parameter)
```php
final readonly class CalibrationService
{
    public function shouldSkipBenchmark(array $data, bool $force): bool
    {
        // ❌ Boolean parameter changes method behavior
        if (!$force && (isset($data['warmupIterations']) || isset($data['innerIterations']))) {
            return true;
        }
        
        $category = is_string($data['category'] ?? null) ? $data['category'] : '';
        return in_array($category, ['Iteration', 'Loop'], true);
    }
}

// Usage:
if ($this->calibrationService->shouldSkipBenchmark($data, $force)) {
    // Skip benchmark
}
```

**Problems:**
- ❌ Boolean parameter changes method behavior
- ❌ Unclear what `true` or `false` means at call site
- ❌ Hard to add more configuration options
- ❌ Parameters can be accidentally swapped

#### AFTER (Value Object)
```php
// Value Object
final readonly class CalibrationOptions
{
    public function __construct(
        public bool $isDryRun,
        public bool $forceRecalibration,
    ) {}

    public static function fromFlags(bool $dryRun, bool $force): self
    {
        return new self(isDryRun: $dryRun, forceRecalibration: $force);
    }

    public function shouldUpdateFixtures(): bool
    {
        return !$this->isDryRun;
    }

    public function shouldSkipConfigured(): bool
    {
        return !$this->forceRecalibration;
    }
}

// Refactored Service
final readonly class CalibrationService
{
    public function shouldSkipBenchmark(array $data, CalibrationOptions $options): bool
    {
        // ✅ Self-documenting method call
        if ($options->shouldSkipConfigured() && (isset($data['warmupIterations']) || isset($data['innerIterations']))) {
            return true;
        }
        
        $category = is_string($data['category'] ?? null) ? $data['category'] : '';
        return in_array($category, ['Iteration', 'Loop'], true);
    }
}

// Usage:
$options = CalibrationOptions::fromFlags($dryRun, $force);
if ($this->calibrationService->shouldSkipBenchmark($data, $options)) {
    // Skip benchmark
}
```

**Benefits:**
- ✅ Self-documenting - `shouldSkipConfigured()` vs `!$force`
- ✅ Type-safe - Can't accidentally swap parameters
- ✅ Cohesive - Related options grouped together
- ✅ Extensible - Easy to add new options without changing signatures

---

## P2.3: Else Clauses → Early Returns

### Example 1: RedisTestResultFormatter

#### BEFORE (Else Clause)
```php
public function displayReadWriteTest(SymfonyStyle $io, array $testResult): void
{
    $io->section('Testing Redis operations');
    $io->writeln(sprintf('SET %s = "%s"', $testResult['key'], $testResult['value']));
    $io->writeln(sprintf('GET %s = "%s"', $testResult['key'], $testResult['retrieved']));

    // ❌ Unnecessary else clause
    if ($testResult['success']) {
        $io->success('Redis read/write test passed!');
    } else {
        $io->error('Redis read/write test failed!');
    }
}
```

**Problems:**
- ❌ Unnecessary else clause
- ❌ Both branches at same indentation level
- ❌ Success path not immediately obvious

#### AFTER (Early Return / Guard Clause)
```php
public function displayReadWriteTest(SymfonyStyle $io, array $testResult): void
{
    $io->section('Testing Redis operations');
    $io->writeln(sprintf('SET %s = "%s"', $testResult['key'], $testResult['value']));
    $io->writeln(sprintf('GET %s = "%s"', $testResult['key'], $testResult['retrieved']));

    // ✅ Guard clause - handle error case first
    if (!$testResult['success']) {
        $io->error('Redis read/write test failed!');
        return;
    }

    // ✅ Success path at top level
    $io->success('Redis read/write test passed!');
}
```

**Benefits:**
- ✅ Guard clause pattern - Error case handled first
- ✅ Success path unindented and obvious
- ✅ Reduced cognitive load - One less branch to track

---

### Example 2: DashboardRenderer::renderWorkerStatus()

#### BEFORE (Else Clause)
```php
public function renderWorkerStatus(SymfonyStyle $symfonyStyle, int $activeWorkers): void
{
    $symfonyStyle->section('Worker Status');

    // ❌ Else clause with multiple statements
    if (0 < $activeWorkers) {
        $symfonyStyle->success(sprintf('%d active workers detected', $activeWorkers));
    } else {
        $symfonyStyle->info('Worker status detection via heartbeat not implemented.');
        $symfonyStyle->note('Workers are managed by supervisor/docker-compose');
    }
}
```

**Problems:**
- ❌ Else clause increases nesting
- ❌ Main logic (success case) buried in if statement
- ❌ Harder to read and understand flow

#### AFTER (Early Return)
```php
public function renderWorkerStatus(SymfonyStyle $symfonyStyle, int $activeWorkers): void
{
    $symfonyStyle->section('Worker Status');

    // ✅ Handle edge case first with early return
    if (0 >= $activeWorkers) {
        $symfonyStyle->info('Worker status detection via heartbeat not implemented.');
        $symfonyStyle->note('Workers are managed by supervisor/docker-compose');
        return;
    }

    // ✅ Main logic at top level
    $symfonyStyle->success(sprintf('%d active workers detected', $activeWorkers));
}
```

**Benefits:**
- ✅ Edge case handled first
- ✅ Main logic unindented
- ✅ Clearer control flow

---

### Example 3: MessengerMonitorCommand::__invoke()

#### BEFORE (Else Clause)
```php
public function __invoke(
    string $interval = '2',
    bool $watch = false,
    ?OutputInterface $output = null,
    ?SymfonyStyle $symfonyStyle = null,
): int {
    // ... validation and setup ...

    // ❌ Else clause for mode selection
    if ($watch) {
        $this->runWatchMode($symfonyStyle, $output, $redis, $intervalSeconds);
    } else {
        $this->showDashboard($symfonyStyle, $output, $redis);
    }

    return Command::SUCCESS;
}
```

**Problems:**
- ❌ Both modes at same indentation
- ❌ Return statement separated from logic
- ❌ Not clear which is the default mode

#### AFTER (Early Return)
```php
public function __invoke(
    string $interval = '2',
    bool $watch = false,
    ?OutputInterface $output = null,
    ?SymfonyStyle $symfonyStyle = null,
): int {
    // ... validation and setup ...

    // ✅ Handle default (simpler) case first
    if (!$watch) {
        $this->showDashboard($symfonyStyle, $output, $redis);
        return Command::SUCCESS;
    }

    // ✅ Watch mode logic separate and clear
    $this->runWatchMode($symfonyStyle, $output, $redis, $intervalSeconds);
    return Command::SUCCESS;
}
```

**Benefits:**
- ✅ Default case handled first
- ✅ Each mode has its own return
- ✅ Easier to extend with more modes

---

### Example 4: DashboardRenderer::renderQueueStatusMessages()

#### BEFORE (Else Clause)
```php
public function renderQueueStatusMessages(
    SymfonyStyle $symfonyStyle,
    int $totalPending,
    int $failedCount,
): void {
    // ❌ Else clause for mutually exclusive conditions
    if (0 < $totalPending) {
        $symfonyStyle->warning(sprintf('%d messages pending processing', $totalPending));
    } else {
        $symfonyStyle->success('All queues are empty');
    }

    if (0 < $failedCount) {
        $symfonyStyle->error(sprintf('%d failed messages! Run "messenger:failed:retry" to retry them.', $failedCount));
    }
}
```

**Problems:**
- ❌ Else clause for simple condition
- ❌ Success message buried in else
- ❌ Not immediately clear conditions are mutually exclusive

#### AFTER (Independent Conditions)
```php
public function renderQueueStatusMessages(
    SymfonyStyle $symfonyStyle,
    int $totalPending,
    int $failedCount,
): void {
    // ✅ Independent conditions - each stands alone
    if (0 >= $totalPending) {
        $symfonyStyle->success('All queues are empty');
    }

    if (0 < $totalPending) {
        $symfonyStyle->warning(sprintf('%d messages pending processing', $totalPending));
    }

    if (0 < $failedCount) {
        $symfonyStyle->error(sprintf('%d failed messages! Run "messenger:failed:retry" to retry them.', $failedCount));
    }
}
```

**Benefits:**
- ✅ Each condition independent
- ✅ Linear flow - easier to understand
- ✅ No unnecessary else clauses

---

## Summary of Improvements

### P2.2: Boolean Flags → Strategy Pattern
- ✅ Eliminated 1 constructor boolean flag
- ✅ Eliminated 2+ method boolean parameters
- ✅ Implemented Strategy Pattern for outlier handling
- ✅ Created Value Object for configuration
- ✅ Improved testability and maintainability

### P2.3: Else Clauses → Early Returns
- ✅ Eliminated 4 else clauses
- ✅ Applied guard clause pattern
- ✅ Reduced nesting and indentation
- ✅ Improved code readability
- ✅ Clearer control flow

### Overall Code Quality
- ✅ PHPStan Level 9: Pass
- ✅ PSR-12: Compliant
- ✅ SOLID Principles: Enhanced
- ✅ Design Patterns: Properly applied
- ✅ No functionality regressions
